
//ray marching complete
const auto inv = Math::Hagedorn::computeInvariants(file.value());
AsyncRenderer renderer;
renderer.start(64, w.width, w.height, [&](size_t _threat_index, size_t _x, size_t _y){

    using Vector = Eigen::Matrix<double, Eigen::Dynamic, 1>;

    const Eigen::Matrix<double, 2, 1> bounds = Eigen::Matrix<double, 2, 1>(double(w.width), double(w.height));
    const Eigen::Matrix<double, 2, 1> uv = Eigen::Matrix<double, 2, 1>(double(_x), double(_y));
    const Eigen::Matrix<double, 2, 1> pp = (2. * uv - bounds) / bounds(1);  //eye ray

    const Vec3 r_o = cam.position + w.scale*(pp(0) * cam.right + pp(1) * cam.up );
    const Vec3 r_d = cam.dir;

    const double dS = w.maxDist / double(w.steps);

    Eigen::Matrix<double, 3, 1> col;
    col.setZero();

    double t = 0.;
    double transmission = 1.;

    const bool hit = Math::intersect(r_o, r_d, w.lower, w.upper, w.maxDist, t); 
    t +=dS;
    if(!hit){   

        col(0) = col(1) = col(2) = 0.;

    } else if(w.steps == 1){   

        col(0) = 1.;
        transmission = 0.;
                
    } else {
    
        for (size_t s = 0; s < w.steps; ++s) {
            const Vector pos = r_o + t * r_d;
            t += dS;

            if(t > w.maxDist || 
                pos(0) < w.lower(0) || 
                pos(1) < w.lower(1) ||
                pos(2) < w.lower(2) ||
                pos(0) > w.upper(0) ||
                pos(1) > w.upper(1) ||
                pos(2) > w.upper(2)
            )
                break;

            //calculate basis function
            const std::unordered_map<Eigen::Index, std::complex<double>> phis = Math::Hagedorn::compute(
                w.curT,
                pos,
                inv
            );

            std::complex<double> res (0., 0.);
            for(Eigen::Index k = 0; k < file.value().Ks.size(); ++k){ 
                const Eigen::Index idx = Math::Hagedorn::Detail::index(file.value().Ks[k], file.value().k_max);
                assert(phis.contains(idx));
                const std::complex<double>& p = (*phis.find(idx)).second;
                res += file.value().c_0[w.curT](k) * p;
            } 
            res *= std::exp(std::complex<double>(0., 1.) * file.value().S(Eigen::Index(w.curT)));

            //compute color
            const auto hsl = Math::c_to_HSL(double(w.MAX), res);
            transmission *= std::exp(-hsl(2) * dS);
            const auto rgb = Math::HSL_to_RGB_rad(hsl);
            col += transmission * rgb * dS;

            if(renderer.isShutdown() || renderer.isRestart(_threat_index))
                return;
        }
    }        
    const size_t idx = _y * cam.width + _x;
    buffer[4 * idx] = col(0);
    buffer[4 * idx + 1] = col(1);
    buffer[4 * idx + 2] = col(2);
    buffer[4 * idx + 3] = (1. - transmission);
});

//File
template<class T>
struct File {
    size_t dimensions;
    size_t timesteps;
    size_t K;
    T epsilon = 1.;  
    Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1> S;       
    std::vector<Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1>> c_0;
    std::vector<Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1>> p, q;
    std::vector<Eigen::Matrix<std::complex<T>, Eigen::Dynamic, Eigen::Dynamic>> P, Q;
    //shapefunction
    std::vector<Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1>> Ks; 
    Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1> k_max; //max k in d direction
    std::unordered_map<Eigen::Index, bool> b_Ks;
};//File

//load from file
template <class T>
inline const std::optional<IO::File<T>> IO::loadFromFile(std::filesystem::path _path, size_t _dims, size_t _K) {

    using Vector = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1>;
    using Matrix = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, Eigen::Dynamic>;

    if(!std::filesystem::exists(_path))
        throw std::runtime_error("file does not exist");

    IO::File<T> out;
    out.dimensions = _dims;
    out.K = _K;

    try {

        //file
        HighFive::File file(_path.string(), HighFive::File::ReadOnly);

        //timesteps
        {
            const Eigen::Matrix<T, Eigen::Dynamic, 1> steps = H5Easy::load<Eigen::Matrix<T, Eigen::Dynamic, 1>>(file, "datablock_0/wavepacket/timegrid");
            out.timesteps = steps.rows();
        }

        //S
        {
            const H5Easy::DataSet dataset = file.getDataSet("datablock_0/wavepacket/Pi/S");
            std::vector<std::vector<std::vector<std::complex<T>>>> S;
            dataset.read(S);
            out.S.resize(S.size());
            for(size_t i = 0; i < S.size(); ++i){
                out.S(i) = S[i][0][0];
            }
        }
    
        //c_0
        {
            const Matrix tmp = H5Easy::load<Matrix>(file, "datablock_0/wavepacket/coefficients/c_0");
            for(size_t t = 0; t < out.timesteps; ++t){
                Vector c_0(tmp.cols());
                for(size_t d = 0; d < tmp.cols(); ++d)
                    c_0(d) = tmp(t, d);
                out.c_0.push_back(std::move(c_0));
            }
        }
      
        //p
        {
            const H5Easy::DataSet dataset = file.getDataSet("datablock_0/wavepacket/Pi/p");
            std::vector<std::vector<std::vector<std::complex<T>>>> p;
            dataset.read(p);
            for(size_t t = 0; t < p.size(); ++t){
                Vector temp(out.dimensions);
                for(size_t y = 0; y < p[t].size(); ++y){
                    temp(y) = p[t][y][0];
                }
                out.p.push_back(std::move(temp));
            }
        }
     
        //q
        {
            const H5Easy::DataSet dataset = file.getDataSet("datablock_0/wavepacket/Pi/q");
            std::vector<std::vector<std::vector<std::complex<T>>>> q;
            dataset.read(q);
            for(size_t t = 0; t < q.size(); ++t){
                Vector temp(out.dimensions);
                for(size_t y = 0; y < q[t].size(); ++y){
                    temp(y) = q[t][y][0];
                }
                out.q.push_back(std::move(temp));
            }
        }
 
        //P
        {
            const H5Easy::DataSet dataset = file.getDataSet("datablock_0/wavepacket/Pi/P");
            std::vector<std::vector<std::vector<std::complex<T>>>> P;
            dataset.read(P);
            for(size_t t = 0; t < P.size(); ++t){
                Matrix temp(out.dimensions, out.dimensions);
                for(size_t x = 0; x < out.dimensions; ++x){
                    for(size_t y = 0; y < out.dimensions; ++y)
                        temp(x, y) = P[t][x][y];
                }
                out.P.push_back(std::move(temp));
            }
        }

        //Q
        {
            const H5Easy::DataSet dataset = file.getDataSet("datablock_0/wavepacket/Pi/Q");
            std::vector<std::vector<std::vector<std::complex<T>>>> Q;
            dataset.read(Q);
            for(size_t t = 0; t < Q.size(); ++t){
                Matrix temp(out.dimensions, out.dimensions);
                for(size_t x = 0; x < out.dimensions; ++x){
                    for(size_t y = 0; y < out.dimensions; ++y)
                        temp(x, y) = Q[t][x][y];
                }
                //std::cout << temp << std::endl;
                out.Q.push_back(std::move(temp));
            }
        }
        

    } catch(const std::exception& _e){
        std::cout << _e.what() << std::endl;
        return {};
    }

    // -------------- cut shape --------------
    {
        out.Ks = hyperbolicCutShape(out.dimensions, out.K);

        out.k_max = Eigen::Matrix<Eigen::Index, -1, 1>(out.dimensions);
        out.k_max.setZero();

        for(size_t i = 0; i < out.dimensions; ++i){
            for(const auto& k : out.Ks){
                out.k_max(i) = std::max(out.k_max(i), k(i));
            }
        }
 
        for(const auto& c : out.Ks){
            const Eigen::Index ii = Math::Hagedorn::Detail::index(c, out.k_max);
            //std::cout << c(0) << ", " << c(1) << ", " << c(2) << " | " << out.k_max(0) << ", " << out.k_max(1) << ", " << out.k_max(2) << " | " << ii << std::endl;
            out.b_Ks.insert( {ii, true} );
        }
    }

    return { out };
}; //loadFromFile

//cut shape
inline std::vector<Eigen::Matrix<Eigen::Index, -1, 1>> IO::hyperbolicCutShape(size_t _dim, size_t _K) noexcept {
    std::vector<Eigen::Matrix<Eigen::Index, -1, 1>> out;

    Eigen::Matrix<Eigen::Index, -1, 1> index(_dim);
    index.setZero();

    while (true) {
        for (index(_dim - 1) = 0; index(_dim - 1) <= _K; ++index(_dim - 1)) {
            Eigen::Index p = 1;
            for (Eigen::Index d = 0; d < _dim; ++d)
                p *= (1 + index(d));
            if (p <= _K)
                out.push_back(index);
        }

        bool done = false;
        for (Eigen::Index d = _dim - 2; d >= 0; --d) {
            index(d) += 1;

            if (index(d) >= _K) {
                if (d == 0)
                    done = true;
                else
                    index(d) = 0;
            } else
                break;
        }
        if (done) break;
    }

    return out;
}; //IO::hyperbolicCutShape

//index
inline Eigen::Index Math::Hagedorn::Detail::index(
    const Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1>& _i, 
    const Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1>& _e
) noexcept {
    assert(_i.size() == _e.size());
    Eigen::Index out = _i(0);
    for (Eigen::Index k = 1; k < _i.size(); ++k) {
        out *= _e(k);
        out += _i(k);
    }
    return out;
}; //Math::Hagedorn::Detail::index

template <class T>
inline std::complex<T> Math::Hagedorn::Detail::phi_0 (
    size_t _t, 
    const Eigen::Matrix<T, Eigen::Dynamic, 1>& _x, 
    const Detail::Invariants<T>& _inv
) noexcept {
    const Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1> xq = _x - _inv.q[_t];
    const Eigen::Matrix<std::complex<T>, 1, Eigen::Dynamic> xqt = xq.transpose();
    const std::complex<T> e1 = _inv.i_2_E_2 * xqt * _inv.P_Q_1[_t] * xq;
    const std::complex<T> e2 = _inv.i_E_2_p[_t] * xq;
    return _inv.pre[_t] * std::exp(e1 + e2);
}; //Math::Hagedorn::Detail::phi_0

template <class T>
inline Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1> Math::Hagedorn::Detail::phi (
    size_t _t,
    const Eigen::Matrix<T, Eigen::Dynamic, 1>& _x,
    const std::unordered_map<Eigen::Index, std::complex<T>>& _phis,
    const Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1>& _index,
    const Detail::Invariants<T>& _inv
) noexcept {

    using Index = Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1>;
    using Vector = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1>;
    using Matrix = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, Eigen::Dynamic>;

    const auto xq = _x - _inv.q[_t];

    Vector res (_inv.dimensions);

    Vector kp (_inv.dimensions);
    for (size_t j = 0; j < _inv.dimensions; ++j) {
        if (_index(j) - 1 < 0) {
            kp(j) = { 0., 0. };
            continue;
        }

        Index k_1 = _index;
        k_1(j) = std::max<Eigen::Index>(k_1(j) - 1, 0ll);
        const Eigen::Index ii = Detail::index(k_1, _inv.k);
        assert(_phis.contains(ii));
        const std::complex<double>& p = (*_phis.find(ii)).second;
        kp(j) = std::sqrt(_index(j)) * p;  
    }

    const Eigen::Index ii = Detail::index(_index, _inv.k);
    assert(_phis.contains(ii));
    const std::complex<double>& p = (*_phis.find(ii)).second;
    auto phi_t = _inv.Q_1[_t] * xq * p - _inv.Q_1_Q_T[_t] * kp;

    Vector phi (_inv.dimensions);
    for(size_t i = 0; i < _inv.dimensions; ++i){
        const T sk = std::sqrt(T(_index(i)) + 1.);
        const std::complex<T> skc = std::complex<T>(sk, 0.);
        phi(i) = phi_t(i) / skc;
    }

    return phi;
}; //Math::Hagedorn::Detail::phi

template <class T>
inline std::unordered_map<Eigen::Index, std::complex<T>> Math::Hagedorn::compute (
    size_t _t, 
    const Eigen::Matrix<T, Eigen::Dynamic, 1>& _x, 
    const Detail::Invariants<T>& _inv
) noexcept {

    using Index = Eigen::Matrix<Eigen::Index, Eigen::Dynamic, 1>;
    using Vector = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1>;
    using Matrix = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, Eigen::Dynamic>;

    const size_t dim = _inv.dimensions;

    size_t size = _inv.k(0) + 1;
    for (size_t i = 1; i < _inv.k.size(); ++i)
        size *= (_inv.k(i)+1);

    std::unordered_map<Eigen::Index, std::complex<T>> phis;

    //iterate over ks
    Index index(dim);
    index.fill(0);

    bool first = true;

    while (true) {
        for (index(dim-1) = 0; index(dim-1) <= _inv.k(dim-1); ++index(dim-1)) { 
            if (first) {
                first = false;
                const auto phi0 = Detail::phi_0(_t, _x, _inv);
                phis.insert( {0, phi0} );
                --index(dim-1);
                continue;
            }

            //check if have reached the end of the shape
            const Eigen::Index ii = Detail::index(index, _inv.k);
            if(!_inv.k_shape.contains(ii))
                break;

            //compute phi for index
            const auto phi = Detail::phi(_t, _x, phis, index, _inv);

            for (size_t d = 0; d < dim; ++d) {
                Index ni = index;
                ni(d) += 1;
                const Eigen::Index ii = Detail::index(ni, _inv.k);
                phis.insert( {ii, phi(d)} );
                //phis[ii] = phi(d);
            }
        }

        bool done = false;
        for (Eigen::Index d = dim - 2; d >= 0; --d) {
            index(d) += 1;
            if (index(d) >=  _inv.k(d)) {
                if (d == 0)
                    done = true;
                else
                    index(d) = 0;
            } else
                break;
        }
        if (done) break;
    }

    return phis;
};//Math::Hagedorn::compute

template<typename T, template<typename> class File>
inline const Math::Hagedorn::Detail::Invariants<T> Math::Hagedorn::computeInvariants(const File<T>& _file) noexcept {
    using Vector = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, 1>;
    using Matrix = Eigen::Matrix<std::complex<T>, Eigen::Dynamic, Eigen::Dynamic>;

    Detail::Invariants<T> out;
    out.dimensions = _file.dimensions;
    out.k = _file.k_max;
    out.i_2_E_2 = std::complex<T>(0., 1.) / (2. * _file.epsilon * _file.epsilon);
    out.p = _file.p;
    out.q = _file.q;
    out.k_shape = _file.b_Ks;

    for(size_t t = 0; t < _file.timesteps; ++t){
        //phi0
        out.pre.push_back( std::pow(T(M_PI) * _file.epsilon * _file.epsilon, -T(_file.dimensions) / 4.) * std::pow(_file.Q[t].determinant(), -0.5) );
        out.P_Q_1.push_back( _file.P[t] * _file.Q[t].inverse() );

        out.i_E_2_p.push_back( (std::complex<T>(0., 1.) / _file.epsilon * _file.epsilon) * _file.p[t].transpose() );
        //phi
        out.Q_1.push_back( std::sqrt(2. / (_file.epsilon * _file.epsilon)) * _file.Q[t].inverse() );
        out.Q_1_Q_T.push_back( _file.Q[t].inverse() * _file.Q[t].conjugate() );
    }
    return out;
}

template<class Vec, class T>
inline bool Math::intersect(const Vec& _r_o, const Vec& _r_d, const Vec& _low, const Vec& _high, T _tmax, T& _t) noexcept {
    _t = -std::numeric_limits<T>::infinity();
    for (size_t i = 0; i < _r_o.size(); ++i) {
        if (std::abs(_r_d[i]) < std::numeric_limits<T>::epsilon()){
            if (_r_o[i] < _low[i] || _r_o[i] > _high[i]) 
                return false;
        } else {
            const T ood = 1. / _r_d[i];
            T t1 = (_low[i] - _r_o[i]) * ood;
            T t2 = (_high[i] - _r_o[i]) * ood;
            if (t1 > t2) std::swap(t1, t2);
            _t = std::max(_t, t1);
            _tmax = std::min(_tmax, t2);
            if (_t > _tmax) return false;
        }
    }
    return true;
}; //intersect

template <class T>
inline Eigen::Matrix<T, 3, 1> Math::c_to_HSL(T _max, const std::complex<T>& _c) noexcept {
    const T H = std::clamp(std::abs(std::fmod(std::arg(_c), 2. * M_PI)), 0., 2. * M_PI);
    const T S = 1.;
    const T L = std::clamp(std::abs(_max * std::atan(std::abs(_c)) / (0.5 * M_PI)), 0., 1.);
    return { H, S, L };
}; //c_to_HSL

template <class T>
inline Eigen::Matrix<T, 3, 1> Math::HSL_to_RGB_rad(const Eigen::Matrix<T, 3, 1>& _hsl) noexcept {
    return HSL_to_RGB_deg<T>( { _hsl(0) * T( 180. / M_PI), _hsl(1), _hsl(2) } );
}; //HSL_to_RGB

template <class T>
inline Eigen::Matrix<T, 3, 1> Math::HSL_to_RGB_deg(const Eigen::Matrix<T, 3, 1>& _hsl) noexcept {

    const T H = _hsl(0);
    const T S = _hsl(1);
    const T L = _hsl(2);

    assert(0. <= H && H <= 360.);
    assert(0. <= S && S <= 1.);
    assert(0. <= L && L <= 1.);

    const T C = ( T(1.) - std::abs( T(2.) * L - T(1.) ) ) * S;
    const T X = C * (T(1.) - std::abs(std::fmod(H / T(60.), T(2.)) - T(1.)));
    const T m = L - C * T(0.5);

    switch(size_t(H / 60.)){
        case 0: return { C + m, X + m, m};
        case 1: return { X + m, C + m, m};
        case 2: return { m, C + m, X + m};
        case 3: return { m, X + m, C + m};
        case 4: return { X + m, m, C + m};
        case 5: return { C + m, m, X + m};
        default: return { 0., 0., 0.};
    }

}; //HSL_to_RGB